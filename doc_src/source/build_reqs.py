# ====================================================================
# Author: William Muntean
# Copyright (C) 2025 William Muntean. All rights reserved.
#
# Licensed under the GPL v3 License;
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://opensource.org/licenses/GPL v3
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ====================================================================

"""
=======================================================
build_reqs.py
=======================================================

This module provides functionality to generate a ``requirements.txt`` file using pigar,
create an ``environment.yml`` file for conda environments, and update the ``pyproject.toml``
with the correct dependencies and Python version constraints.

Dependency and Environment File Generation
==========================================

The requirements and environment setup is performed in the following stages:

1. **Initialization**:

   - Parse command-line arguments to determine whether to use pigar and/or poetry.
   - Identify the project root and relevant file paths.

2. **Requirements Generation**:

   - Optionally run pigar to generate ``requirements.txt``.
   - Parse the requirements file and extract dependencies.

3. **Environment and Project File Update**:

   - Write a new ``environment.yml`` with pip dependencies.
   - Update ``pyproject.toml`` with Python constraints and dependencies.
   - Optionally use poetry to add dependencies and export exact requirements.

.. Note::
    - This script expects ``requirements.txt`` to exist or be generated by pigar.
    - The script must be run from the ``doc_src/source`` directory or adjust the project root accordingly.

.. Important::
    - Ensure that ``pigar`` and ``poetry`` are installed if their features are used.
    - Review the generated ``requirements.txt`` before proceeding.

.. currentmodule:: build_reqs

Standalone Execution
=====================

When run as a standalone script, this module processes the current project's dependencies,
generates ``requirements.txt`` (optionally), creates ``environment.yml``, and updates ``pyproject.toml``.

- Output Files:
    - ``requirements.txt``
    - ``environment.yml``
    - ``pyproject.toml``

.. Note::
   The following paths must be correctly set within the script's ``__main__`` block for successful
   execution:

   - ``project_root``: Defines the root directory of the project.

.. code-block:: bash

    python build_reqs.py

"""

__author__ = "William Muntean"
__email__ = "williamjmuntean@gmail.com"
__license__ = "GPL v3"
__maintainer__ = "William Muntean"
__date__ = "2024-01-23"

import argparse
import re
import subprocess
import sys
from pathlib import Path

import tomlkit

python_version = f"{sys.version_info.major}.{sys.version_info.minor}"
python_constraint = f">={python_version},<4.0"

parser = argparse.ArgumentParser(
    description="Generate environment.yml and update pyproject.toml"
)
parser.add_argument(
    "--use-pigar",
    "-pi",
    action="store_true",
    help="Run pigar to create the requirements.txt file",
)
parser.add_argument(
    "--use-poetry", "-po", action="store_true", help="Add dependencies with Poetry"
)
args, unknown = parser.parse_known_args()

# Prompt if no args
if not (args.use_pigar or args.use_poetry):
    print("=== Requirements File Generator ===")
    args.use_pigar = (
        input("Run pigar to create requirements.txt? (y/n): ")
        .strip()
        .lower()
        .startswith("y")
    )
    args.use_poetry = (
        input("Add dependencies with Poetry? (y/n): ").strip().lower().startswith("y")
    )

# Project root
project_root = Path.cwd().parent.resolve()
# project_root = Path.cwd().resolve()
print(f"Using project root: {project_root}")
req_file = project_root / "requirements.txt"
env_file = project_root / "environment.yml"
poetry_file = project_root / "pyproject.toml"

# Get project name from pyproject
with open(poetry_file, "r", encoding="utf-8") as f:
    toml_data = tomlkit.load(f)  # use tomlkit to load

project_name = toml_data.get("project", {}).get("name") or toml_data.get(
    "tool", {}
).get("poetry", {}).get("name", "your-project-name")

# Run pigar if requested
if args.use_pigar:
    subprocess.run(["pigar", "gen", "-f", str(req_file)], check=True, cwd=project_root)
    input(
        "Press Enter to continue after reviewing `requirements.txt`, or Ctrl+C to abort."
    )

# Parse requirements.txt
if not req_file.exists():
    raise FileNotFoundError(f"`requirements.txt` not found at {req_file}")

with open(req_file, "r") as f:
    requirements = f.readlines()

pip_dependencies = []
for line in requirements:
    match = re.match(r"([\w\-.]+)([=<>!~]*[\d\w\.\*]*)", line.strip())
    if match:
        package, version = match.groups()
        match = re.search(r"[=<>!~]+([\w\.\-]+)", version)
        if match:
            version = match.group(1)
            dep = f"{package}~={version}"
        else:
            version = "0.0.0"  # Default version if none is found
            dep = f"{package}>{version}"
            print(
                f"Warning: No version found for package '{package}'. Using default version '{version}'."
            )
        pip_dependencies.append(dep)

# Write environment.yml
yml_content = [
    f"name: {project_name}",
    "channels:",
    "  - conda-forge",
    "  - defaults",
    "dependencies:",
    f"  - python={python_version}.*",
    "  - pip",
    "  - pip:",
]
yml_content.extend(f"    - {dep}" for dep in pip_dependencies)
with open(env_file, "w") as f:
    f.write("\n".join(yml_content))
print(f"`environment.yml` written to {env_file}")

# --- Update pyproject.toml using tomlkit ---
if "project" not in toml_data:
    toml_data["project"] = {}

toml_data["project"]["requires-python"] = python_constraint
toml_data["project"]["dependencies"] = sorted(pip_dependencies)

# Optional: if using poetry, add via CLI too
if args.use_poetry:
    print("Running poetry to add dependencies...")
    subprocess.run(["poetry", "add"] + pip_dependencies, check=True, cwd=project_root)

    try:
        result = subprocess.run(
            ["poetry", "self", "show", "plugins"],
            check=True,
            cwd=project_root,
            capture_output=True,
            text=True,
        )
        if "poetry-plugin-export" not in result.stdout:
            subprocess.run(
                ["poetry", "self", "add", "poetry-plugin-export"],
                check=True,
                cwd=project_root,
            )
    except subprocess.CalledProcessError as e:
        print("Could not verify or install poetry-plugin-export:", e)

    subprocess.run(
        [
            "poetry",
            "export",
            "-f",
            "requirements.txt",
            "--without-hashes",
            "-o",
            "requirements-exact.txt",
        ],
        check=True,
        cwd=project_root,
    )
    print("Exact requirements exported to requirements-exact.txt")

# Write final toml
with open(poetry_file, "w", encoding="utf-8") as f:
    f.write(tomlkit.dumps(toml_data))
print(f"`pyproject.toml` updated at {poetry_file}")
